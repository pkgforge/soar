//! Support for querying JSON columns.
//!
//! This allows you to treat nested JSON fields as first-class expressions.

use std::marker::PhantomData;

use rusqlite::types::Value;

use crate::traits::Expression;

/// A reference to a field inside a JSON column.
///
/// Uses SQLite's [`json_extract`](https://www.sqlite.org/json1.html#jex) function
/// to extract a scalar value from a JSON object stored in a column.
///
/// This expression can be used in `WHERE`, `SELECT`, or `ORDER BY` clauses.
///
/// # Example
///
/// ```rust
/// use soar_db::expr::JsonField;
/// let user_email = JsonField::<String>::new("metadata", "contact.email");
/// // -> json_extract(metadata, '$.contact.email')
/// ```
pub struct JsonField<T> {
    column: &'static str,
    path: String,
    _type: PhantomData<T>,
}

impl<T> JsonField<T> {
    /// Creates a new JSON field expression.
    ///
    /// - `column`: the name of the database column containing JSON (e.g., `"metadata"`)
    /// - `path`: a dot-separated path to the desired field (e.g., `"user.id"`)
    ///
    /// The path must not contain special characters (like spaces or quotes);
    /// it will be inserted directly into the JSON pointer (`$.{path}`).
    ///
    /// # Example
    ///
    /// ```rust
    /// use soar_db::expr::JsonField;
    /// let uid = JsonField::<String>::new("metadata", "user.id");
    /// ```
    pub fn new(column: &'static str, path: impl Into<String>) -> Self {
        Self {
            column,
            path: path.into(),
            _type: PhantomData,
        }
    }
}

impl<T> Expression for JsonField<T> {
    fn to_sql(&self, _params: &mut Vec<Value>) -> String {
        format!("json_extract({}, '$.{}')", self.column, self.path)
    }
}

/// Intermediate builder for JSON array conditions.
///
/// This type is returned by [`json_contains`] and is used to specify the comparison
/// (e.g., `.eq(...)`, `.like(...)`). It is not meant to be constructed directly.
pub struct JsonArrayContains<T> {
    column: &'static str,
    field: String,
    _type: PhantomData<T>,
}

/// Creates a condition builder for searching within a JSON array of objects.
///
/// Use this when your column stores a **JSON array** like:
/// ```json
/// [{"id": 1, "role": "admin"}, {"id": 2, "role": "user"}]
/// ```
///
/// Under the hood, it uses SQLiteâ€™s [`json_each`](https://www.sqlite.org/json1.html#jeach)
/// table-valued function to iterate over array elements.
///
/// # Parameters
///
/// - `column`: name of the column storing the JSON array (e.g., `"permissions"`)
/// - `field`: the field name inside each array object to inspect (e.g., `"scope"`)
///
/// # Returns
///
/// A [`JsonArrayContains`] builder that supports `.eq()`, `.like()`, etc.
///
/// # Example
///
/// ```rust
/// use soar_db::expr::json_contains;
/// let cond = json_contains::<String>("permissions", "scope").eq("read".to_string());
/// ```
pub fn json_contains<T>(column: &'static str, field: impl Into<String>) -> JsonArrayContains<T> {
    JsonArrayContains {
        column,
        field: field.into(),
        _type: PhantomData,
    }
}

/// Represents a comparison against a field inside objects of a JSON array.
///
/// Generated by calling `.eq()` on [`JsonArrayContains`].
///
/// Uses `EXISTS (SELECT 1 FROM json_each(...))` to check for at least one match.
pub struct JsonArrayOp {
    column: &'static str,
    field: String,
    value: Value,
    op: &'static str,
}

impl Expression for JsonArrayOp {
    fn to_sql(&self, params: &mut Vec<Value>) -> String {
        params.push(self.value.clone());
        format!(
            "EXISTS (SELECT 1 FROM json_each({}) WHERE json_extract(value, '$.{}') {} ?)",
            self.column, self.field, self.op
        )
    }
}

/// Represents a `LIKE` pattern match against a field inside objects of a JSON array.
///
/// Generated by calling `.like()` on [`JsonArrayContains`].
pub struct JsonArrayLikeOp {
    column: &'static str,
    field: String,
    pattern: String,
}

impl Expression for JsonArrayLikeOp {
    fn to_sql(&self, params: &mut Vec<Value>) -> String {
        params.push(format!("%{}%", self.pattern).into());
        format!(
            "EXISTS (SELECT 1 FROM json_each({}) WHERE json_extract(value, '$.{}') LIKE ?)",
            self.column, self.field
        )
    }
}

impl<T> JsonArrayContains<T> {
    /// Checks if **any object** in the JSON array has the specified field **equal** to a value.
    ///
    /// # Example
    ///
    /// ```rust
    /// use soar_db::expr::json_contains;
    /// // Find users who have at least one project with status = "active"
    /// json_contains::<String>("projects", "status").eq("active".to_string());
    /// ```
    pub fn eq<I: Into<Value>>(self, value: I) -> JsonArrayOp {
        JsonArrayOp {
            column: self.column,
            field: self.field,
            op: "=",
            value: value.into(),
        }
    }

    /// Checks if **any object** in the JSON array has the specified field **matching a pattern**.
    ///
    /// The pattern is automatically wrapped in `%` on both sides (i.e., substring match).
    ///
    /// # Example
    ///
    /// ```rust
    /// use soar_db::expr::json_contains;
    /// // Find users with a project whose name contains "auth"
    /// json_contains::<String>("projects", "name").like("auth".to_string());
    /// ```
    pub fn like(self, pattern: impl Into<String>) -> JsonArrayLikeOp {
        JsonArrayLikeOp {
            column: self.column,
            field: self.field,
            pattern: pattern.into(),
        }
    }
}
